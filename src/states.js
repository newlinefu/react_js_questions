const TITLE_REACT_JSX = 'JSX'
const TITLE_REACT_LIFECYCLE = 'Жизненный цикл'
const TITLE_REACT_HOOKS  = 'Хуки'
const TITLE_REACT_OTHER = 'Прочее'

const TITLE_JS_TYPES = 'Типы данных'
const TITLE_JS_CAST = 'Приведение типов'
const TITLE_JS_OBJECTS = 'Работа с объектами'
const TITLE_JS_FUNCTIONS = 'Функции'
const TITLE_JS_PROTOTYPES = 'Наследование и прототипы'
const TITLE_JS_CLASSES = 'Классы'
const TITLE_JS_ASYNC = 'Ассинхронность'
const TITLE_JS_EVENTS = 'События'

class Question {
    constructor(title, question, answer) {
        this.title = title
        this.question = question
        this.answer = answer
    }
}

export const reactQState = {
    titles: [
        TITLE_REACT_JSX,
        TITLE_REACT_LIFECYCLE,
        TITLE_REACT_HOOKS,
        TITLE_REACT_OTHER
    ],

    questions: [

        new Question(
            TITLE_REACT_JSX,
            'Что такое JSX?',
            `Расширение JavaScript, созданное для более комфортной работы с компонентами React.`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Во что превращается jsx после компиляции?',
            `В JavaScript объекты со структурой type, props. В props помимо пользовательский props
        есть поле children, отражающее внутреннее содержимое тега`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Является ли JSX выражением?',
            `Да`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Как можно создать React элемент без JSX?',
            `const element = React.createElement(
		  type of element,
		  Объект props,
		  children
		);`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Какое главное условие для использования JSX?',
            `React должен находиться в области видимости`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Какой JS код можно встраивать в JSX?',
            `Любой, являющийся выражением`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Главное свойство JSX элементов?',
            `Иммутабельность`
        ),

        new Question(
            TITLE_REACT_JSX,
            'От чего начинается рендеринг всех элементов и компонент?',
            `От корневого элемента. В create-react-app это 'root'. Корневых элементов может быть несколько`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Метод для рендеринга в нужный узел ДОМ',
            `ReactDOM.render(element, document.getElementById('root'));`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Что такое компонента?',
            `В зависимости от того, к какому типу компонента относится определение может отличаться.
        Если компонента функциональная - функция, принимающая объект props и возвращающая JSX элемент
        Если компонента классовая - класс с обязательным методом рендер, который возвращает JSX элемент`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Какие компоненты бывают? Когда какую лучше использовать',
            `Классовые, функциональные. Контейнерные, презентационные.
        Если необходим доступ к методом жизненного цикла, то классовую. Если нет - функциональную`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Что может описываться в пропсах?',
            `JS выражения`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Какое правило должна соблюдать любая компонента по отношению к своим пропсам?',
            `Должна быть чистой`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Как правильно определять состояние в классовых компонентах?',
            `Либо в полях класса, либо в конструкторе обычным присваиванием (this.state = ....)`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Как правильно обновлять состояние, опирающееся на предыдущее?',
            `В метод setState передать callback, принимающий prevState, prevProps. Данный callback
        должен вернуть новое состояние. Делать так необходимо из-за ассинхронности изменения 
        состояния`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Обязательно ли обновлять все состояние при необходимости изменения лишь части?',
            `Нет, React после изменения части состояния собирает новое состояние. Пожтому можно 
        передать лишь часть состояния`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Как называется передача состояния дочерним компонентам?',
            `Нисходящая`
        ),

        new Question(
            TITLE_REACT_JSX,
            'Жизненный цикл. Диаграмма',
            `Монтирование: constructor => getDerivedStateFromProps => render => componentDidMount. 
        Обновление: изменение пропсов, состояния, контекста, форс => getDerivedStateFromProps => shouldComponentUpdate => render => GetSnapshotBeforeUpdate => componentDidUpdate. 
        Размонтирование: componentWillUnmount`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Отличие обработки событий в HTML от React',
            `В React в качестве обработчика передается callback. В HTML передается строка, содержащая JS код`
        ),

        new Question(
            TITLE_REACT_OTHER,
            'Как в React можно предотвратить событие по умолчанию?',
            `Только e.preventDefault(). Возврат false не сработает`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Особенности рендеринга null, undefined',
            `Они, а также true, false не будут рендериться, только если их не привести к строке`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Что такое ключ?',
            `Ключ - особый JSX аттрибут, который должен быть у элементов, отрисованных в цикле. Нужно это для 
        контроля над производительностью и уникальной идентификации каждого отрисованного элемента`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Когда нельзя использовать индексы как ключи?',
            `Когда может измениться порядок элементов`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Где необходимо задавать ключ?',
            `В элементе JSX, который является результатом рендеринга на каждой итерации. Не его дочерние элементы`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Что такое управляемые компоненты?',
            `Компоненты, сосотоянием которых можно управлять`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Пример неуправляемого компонента и управляемого компонента',
            `input file, input textarea`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Фрагменты, запись фрагментов.',
            `Либо с помощью <React.Fragment></React.Fragment>, либо с помощью <></>`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Что такое бандл? Динамический импорт, lazy',
            `Бандл - файл сборки. const importedComponent = import('./imported_component_path'). 
        const lazyImportedComponent = React.lazy(() => import('./imported_component_path'))`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Для чего нужен контекст? Синтаксис контекста',
            `Контекст необходим для передачи данных в дочерние компоненты без прокидывания их через пропсы.
        Сначала объявляется контекст const Context = React.createContext(значение по умолчанию). Значение по 
        умолчанию передается только если нет контекста того же типа выше по иерархии. Далее идет 
        доступ к контексту. Все дочерние компоненты, которые должны иметь доступ оборачиваются
        <Context.Provider value = прокидываемое значение></Context.Provider>. В классовой компоненте необходимо
        взять доступ static contextType = Context. После этого можно обращаться к нему this.context.value.
        В функциях используется <Context.Consumer> value => .... </Context.Consumer>`
        ),

        new Question(
            TITLE_REACT_OTHER,
            'Когда задается значение контекста по умолчанию?',
            `Когда значение контекста того же типа не задано выше по иерархии`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Возможная потеря производительности при использовании контекста',
            `Если передать в контекст объект, тогда при каждой новой отрисовке будет создаваться
        новый объект => будет происходить новая отрисовка`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Что такое предохранители?',
            `Классовый компонент, в котором определен метод жизненного цикла componentDidCatch или getDerivedStateFromError`
        ),

        new Question(
            TITLE_REACT_OTHER,
            'Где предохранители не могут поймать ошибки?',
            `Внутри себя, в обработчиках событий, при серверном рендеринге, в ассинхронном коде`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Что такое компонента высшего порядка?',
            `Функция, принимающая компоненту и возвращающая новую компоненту`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Что такое портал и зачем он нужен?',
            `Специальная функция, позволяющая вмонтировать элемент в любое место DOM.`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Ограничения PureComponent. Использование React.memo',
            `Необходимо, чтобы дочерние компоненты были чистыми`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'Как клонировать элемент?',
            `React.cloneElement`
        ),


        new Question(
            TITLE_REACT_OTHER,
            'как проверить что элемент является объектом реакт?',
            `React.isValid`
        ),


        new Question(
            TITLE_REACT_LIFECYCLE,
            'Сколько обязательных методов жизненного цикла у классовой компоненты?',
            `Всего один. render()`
        ),


        new Question(
            TITLE_REACT_LIFECYCLE,
            'Какие действия можно делать в конструкторе?',
            `Инициализация состояния, привязка эвентов`
        ),


        new Question(
            TITLE_REACT_LIFECYCLE,
            'Когда не вызывается shoudComponentUpdate?',
            `При первом рендере`
        ),

        new Question(
            TITLE_REACT_LIFECYCLE,
            'Когда может понадобиться getDerivedStateFromProps',
            `Когда состояние зависит от изменений в пропсах`
        ),

        new Question(
            TITLE_REACT_LIFECYCLE,
            'Какие условия использования setState и какие параметры он принимает?',
            `Объект состояния не должен мутировать. Компонента всегда перерисовывается, только если его не блокирует 
        shouldComponentUpdate. Принимает 2 параметра. Первый - функция изменения состояния на основе предыдущего,
        второй - callback, вызванный после изменения состояния`
        ),

        new Question(
            TITLE_REACT_LIFECYCLE,
            'Что может вернуть render? Когда render не вызывается?',
            `boolean, null, undefined, строки, JSX элемент, фрагмент, порталы`
        ),

        new Question(
            TITLE_REACT_HOOKS,
            'Когда не следует использовать хуки?',
            `В условии и в цикле. В классовых компонентах`
        ),


        new Question(
            TITLE_REACT_HOOKS,
            'Что такое хук?',
            `Функция, которая позволяет привязаться к состоянию компоненты`
        ),


        new Question(
            TITLE_REACT_HOOKS,
            'Как можно сделать подписку и отписку на событие в хуке эффекта?',
            `Подписку - обычным образом, отписку - вернув функцию отписки из хука`
        ),

    ]
}

export const jsQState = {
    titles: [
        TITLE_JS_TYPES,
        TITLE_JS_CAST,
        TITLE_JS_OBJECTS,
        TITLE_JS_FUNCTIONS,
        TITLE_JS_PROTOTYPES,
        TITLE_JS_CLASSES,
        TITLE_JS_ASYNC,
        TITLE_JS_EVENTS
    ],

    questions: [
        new Question(
            TITLE_JS_TYPES,
            'Сколько всего типов данных в JS. Какие?',
            '8. Number, String, Boolean, null, undefined, Symbol, Bigint, object'
        ),
        new Question(
            TITLE_JS_TYPES,
            'Как JS вызывает методы примитивов?',
            'Он создает специальную объект-обертку над примитивом на время использования метода'
        ),
        new Question(
            TITLE_JS_TYPES,
            'Какие есть классы у примитивов и почему не вызываются конструкторы у данных классов',
            'Одноименные классы, такие как Number, String, Boolean. При вызове конструкторов созданный примитив становится объектом'
        ),
        new Question(
            TITLE_JS_TYPES,
            'Какие типы не имеют методов?',
            'null, undefined'
        ),
        new Question(
            TITLE_JS_TYPES,
            'Что будет, если объекту-обертке задать какое-либо поле',
            'В strict mode будет выведена ошибка, т.к. данный объект неизменяем'
        ),
        new Question(
            TITLE_JS_TYPES,
            'Какие есть числа в JS? Примеры записи. Как вызывать метод над числом?',
            '0b1 - двоичные, 0o1 - восьмеричные, 0x1 - шестнадцатеричные. 123..toString()'
        ),
        new Question(
            TITLE_JS_TYPES,
            'Как происходит сравнение строк? Какие кавычки можно использовать в JS и в чем их отличие?',
            'Познаково с начала строки в соответствии с юникодом'
        ),
        new Question(
            TITLE_JS_TYPES,
            `Что такое массив? 
            Какие возможности в JS предоставляет массив как объект, но нежелательны к использованию? 
            Как можно быстро очистить массив?`,
            `Упорядоченная проиндексированная коллекция данных. 
            Запись свойств, оставления пустых дыр, заполнение с конца, перебор циклом for..in..
            Установить значение a.length = 0`
        ),
        new Question(
            TITLE_JS_TYPES,
            'Как можно скопировать массив?',
            '[].concat(a), [...a], JSON.stringify, a.slice(0), Object.assign'
        ),
        new Question(
            TITLE_JS_TYPES,
            `Сделать итерируемый объект. Что такое итерируемый объект? Что такое псевдомассив? 
            Как преобразовать эти объекты к массиву?`,
            'Ответ - код'
        ),
        new Question(
            TITLE_JS_TYPES,
            `Map. Типы перебора Map, создание через конструктор, из объекта`,
            'Ответ - код'
        ),
        new Question(
            TITLE_JS_TYPES,
            'В чем разница между null и undefined',
            `undefined используется для значений перемменных, которые не были инициализированы, также функции,
            не возвращающие никакого значения по умолчанию возвращают undefined. Null используется для значений переменных,
            которые были инициализированы, но значение отсутствует`
        ),
        new Question(
            TITLE_JS_CAST,
            'Назвать все Falsy Values',
            'Пустая строка, 0, null, undefined, false, NaN'
        ),
        new Question(
            TITLE_JS_CAST,
            'Назвать псевдоистинные значения',
            '[], {}, function(){}'
        ),
        new Question(
            TITLE_JS_CAST,
            `Дать ответ на следующие вопросы: 
            (1) undefined + 2 = ? 
            (2) null + 2 = ? 
            (3) '1' + 2 = ? 
            (4) 2 + '1' = ? 
            (5) 10 + 'px' + 3 = ?
            (6) 10 + 2 + 'px'`,
            `(1): NaN, 
            (2): 2
            (3): 12
            (4): 12
            (5): 10px3
            (6) 12px
            `
        ),
        new Question(
            TITLE_JS_CAST,
            `Назвать разницу между == и ===. Дать ответ на следующие вопросы: 
            (1) NaN == NaN = ? 
            (2) NaN === NaN = ? 
            (3) undefined == null = ? 
            (4) undefined === null = ? 
            (5) '0' == false = ?
            (6) '0' == 0 = ?
            (7) false == '' = ? 
            (8) false == [] = ? 
            (9) false == {} = ? 
            (10) '' == 0 = ? 
            (11) '' == [] = ? 
            (12) '' == {} = ? 
            (13) 0 == [] = ? 
            (14) 0 == {} = ? 
            (15) 0 == null = ?
            (16) null >= 0 = ?
            (17) undefined == 0 = ?
            (18) undefined < 0 = ?
            (19) undefined > 0 = ?
            `,
            `(1) false 
            (2) false 
            (3) true
            (4) false
            (5) true
            (6) true
            (7) true
            (8) true
            (9) false
            (10) true
            (11) true
            (12) false
            (13) true
            (14) false
            (15) false
            (16) true
            (17) false
            (18) false
            (19) false`
        ),
        new Question(
            TITLE_JS_OBJECTS,
            'Что такое поля объекта? Как еще называются поля объекта? Как к ним можно обращаться? Можно ли использовать зарезервированные имена в качестве ключа? Как узнать, что поле существует у объекта?',
            `Поле объекта - ключ, по которому можно обратиться к значению объекта. Свойство объекта. 
            Для вычисляемых свойств можно обращаться через obj[key], обычно обращение идет через obj.key. Если 
            у имя свойства объекта должно состоять из нескольких слов => необходимо записывать его в кавычках ("key one": val), да. С помощью ключевого слова in`
        ),
        new Question(
            TITLE_JS_OBJECTS,
            'Как возможно проверить, что поле существует без специально предназначенных средтв языка? В чем минус данного подхода?',
            `Обычная проверка на undefined, однако это не сработает, если поле существует и имеет поле с данным значением`
        ),
        new Question(
            TITLE_JS_OBJECTS,
            'Упорядочены ли свойства в объекте? Как можно обойти данное упорядочение?',
            `Да. Те свойства, ключи которых можно привести к number расположены в порядке возрастания, 
            другие находятся после, по мере их создания. Если ключ не целочисленный, то он тоже будет сортироваться в 
            зависимости от создания`
        ),
        new Question(
            TITLE_JS_OBJECTS,
            'Зачем нужен тип данных Symbol?',
            `Для создания уникальных свойств объекта. К ним нельзя нечаянно обратиться, 
            они не перебираются в цикле, но копируются Object.assign`
        ),
        new Question(
            TITLE_JS_OBJECTS,
            'Что такое this? При каких случаях может быть потерян контекст вызова?',
            'Контекст вызова. При вызове метода по ссылке на саму функцию, например при (obj.name == "me" ? obj.hi : obj.bye)()'
        ),
        new Question(
            TITLE_JS_OBJECTS,
            `Объяснить вывод: let obj, method;

            obj = {
              go: function() { alert(this); }
            };
            obj.go();
            
            (obj.go)();             
            
            (method = obj.go)();    
            
            (obj.go || obj.stop)();`,
            `Объект, объект, undefined, undefined`
        ),
        new Question(
            TITLE_JS_OBJECTS,
            `Каким будет результат?
            function makeUser() {
              return {
                name: "Джон",
                ref: this
              };
            };
            
            let user = makeUser();
            
            alert( user.ref.name );`,
            `Error`
        ),
        new Question(
            TITLE_JS_OBJECTS,
            'Как можно задать конфигурацию приведения Object к приминиву?',
            `Либо Symbol.toPrimitive(hint), либо методами toString(), valueOf(). 
            Первый обязан возвращать примитив, иначе будет ошибка, вторые же могут возвращать объекты, 
            но значение будет проигнорировано`
        ),
        new Question(
            TITLE_JS_OBJECTS,
            'Что происходит при вызове функции через оператор new? Что будет если вызвать конструктор без скобок?',
            'неявное создание this, выполнение кода функции, неявный возврат this. Принимаемые аргументы станут undefined, ошибки не будет'
        ),
        new Question(
            TITLE_JS_OBJECTS,
            'Что такое флаги? Какие флаги существуют? Какие методы позволяют получить флаги? Что такое getters, setters?',
            `Специальные атрибуты объекта. Writable, enumerable, configurable. 
            Object.getOwnPropertyDescriptor(o, property) - для отдельного свойства,
            Object.defineProperty(o, property, descriptor) - для изменения свойства,
            Object.defineProperties(o,  objectOfProps) - для изменения нескольких свойств,
            Object.getOwnPropertyDescriptors(o) - получение всех дескрипторов свойств.
            Дескрипторы свойств доступа, которые определяются как функции, не имеют свйоства value`
        ),
        new Question(
            TITLE_JS_FUNCTIONS,
            'Что такое замыкание в JS? Для чего нужно замыкание',
            `Замыкание - функция, которая запоминает свои внешние переменные и имеет к ним доступ.
            В JS все функции являются замыканиями.`
        ),
        new Question(
            TITLE_JS_FUNCTIONS,
            'Что такое IIFE',
            'Immediately-invoked function expressions. Функции, вызываемые сразу после создания'
        ),
        new Question(
            TITLE_JS_FUNCTIONS,
            'Что лежит в основе замыкания?',
            `Лексическое окружение. Если сохранить вызов функции в переменную - лексическое 
            окружение останется досутпным и к нему можно будет обращаться`
        ),
        new Question(
            TITLE_JS_FUNCTIONS,
            'Основные отличия var от let/const',
            `(1) Всплытие 
            (2) Нечувствительность к блочной области видимости 
            (3) Запись в глобальный объект`
        ),
        new Question(
            TITLE_JS_FUNCTIONS,
            'Основные поля функции. Что такое NFE? Главные свойства NFE',
            `name, length. Named Function Expression, объявление имени функции при Function expression.
            При этом такое дополнительное имя может использоваться только внутри, недоступно извне.`
        ),
        new Question(
            TITLE_JS_FUNCTIONS,
            'Зачем необходим вызов new Function()?',
            `Для строкового вызова функции. Данная функция не имеет доступа к внешним переменным 
            из-за минификации имен. Первый параметр - переменные, второй - строка с функцией`
        ),
        new Question(
            TITLE_JS_FUNCTIONS,
            'В чем отличие bind от call, apply? Реализовать собственный bind, при условии, что у нас есть call и apply',
            'bind создает обертку'
        ),
        new Question(
            TITLE_JS_PROTOTYPES,
            'Что такое __proto__? Какие у него ограничения? Как ведет себя this при использовании унаследованных методов? Как можно взаимодействовать с объектом-родителем через прототип?',
            `Исторически обусловленный геттер/сеттер для свойства прототипа. Имеет ссылку на объект родителя,
            от которого наследуется объект. Ссылки не могут быть цикличными, ссылка может иметь либо значение объекта, 
            либо null. Прототипы никак не влияют на this, важен лишь объект перед точкой. Прототип используется 
            только для чтения, записать через него невозможно.`
        ),
        new Question(
            TITLE_JS_PROTOTYPES,
            'Что такое свойство prototype? Какое условие для его использования? Как оно связано с создаваемыми объектами?',
            `Свойство для функции, указывающее на почти пустой объект, который станет прототипом для всех
            объектов, созданных с помощью данной функции. Вызов через ключевое слово new. Единоразовый подарок создаваемому объекту`
        ),
        new Question(
            TITLE_JS_PROTOTYPES,
            'Реализовать функцию, эмулирующую ключевое слово new',
            `Создается объект, ему присваивается прототип конструктора, а после все это привязывается 
            к функции конструктора`
        ),
        new Question(
            TITLE_JS_CLASSES,
            `Что будет если вызвать конструктор класса без оператора new? Что будет если 
            вызвать конструктор класса-наследника без ключевого слова super?`,
            `Произойдет ошибка. This вернется undefined, создание объекта отводится родительскому классу`
        ),
        new Question(
            TITLE_JS_ASYNC,
            `Что такое ад коллбэков, как его можно избежать?`,
            `Такая структура кода, при которой код растет в ширину. В данном случае из-за многомерности 
            вложенных вызовов. Разнести вложенные вызовы по функциям или использовать Promise`
        ),
        new Question(
            TITLE_JS_ASYNC,
            `Синтаксис Promise, что принимает и как называются аргументы? Что принимает принимаемая функция?
            Как происходит возврат из Promise? Можно ли возвратить из промисса и ошибку и успешный результат?`,
            `new Promise(function(resolve, reject) => {...}). Принимает функцию executor, она в
            свою очередь примает функции возвращения положительного и отрицательного результата. Для возврата необходимо
            вызвать одну из функций, отдавая в качестве аргумента возвращаемое из промисса значение. Вернуть можно лишь
            один аспект, другой будет проигнорирован. В качетсве желаемого параметра reject должен выступать экземпляр 
            класса Error`
        ),
        new Question(
            TITLE_JS_ASYNC,
            `Какие есть методы Promise? Что они принимают и какой когда необходимо использовать?`,
            `(1) then(f, f) - метод, обрабатывающий результат промисса, возвращает Promise, принимает 2 функции. 
            Первая - функция обработки положительного результата, вторая - обработки ошибки предыдущего промисса. (2)
            catch(f) - метод обработки перехода промисса в состояние выполнен с ошибкой. (3) finally(f) - метод, выполняемый
            в любом случае, чаще всего необходим для очистки побочных эффектов промисса. Функция-аргумент finally 
            не принимает ничего`
        ),
        new Question(
            TITLE_JS_ASYNC,
            `Обязательно ли для прехвата ошибки в Promise использовать reject?`,
            `Нет, можно использовать и обычный throw, он будет перехвачен.`
        ),
        new Question(
            TITLE_JS_ASYNC,
            `Зачем необходимы методы Promise.all, Promise.race?`,
            `Promise.all(iterable) принимает в себя массив(или любую другую итерируемую структуру данных) и ждет
            завершения всех промиссов, входящих в данную структуру. Возвращает массив их результатов после завершения всех промиссов.
            Если хотя бы один завершился с ошибкой - возвращает ошибку. Promise.race имеет те же аргументы, но возвращает
            результат первого промисса.`
        ),
        new Question(
            TITLE_JS_EVENTS,
            `В чем преимущество addEventListener перед стандартными методами on... Как удалить одно 
            повешенное событие в обоих случаях`,
            `Можно повесить несколько функций на одно событие. В первом случае вызывается removeEventListener,
            принимающий название события и ссылку на функцию, переданную в addEventListener. Второй обработчик 
            можно удалить просто дав значение null.`
        ),
        new Question(
            TITLE_JS_EVENTS,
            `Какие аргументы принимает addEventListener?`,
            `type, обработчик, может быть объектом handleEvent. Так можно использовать методы созданных классов.
            А также объект конфигурации.`
        ),
        new Question(
            TITLE_JS_EVENTS,
            `Что такое всплытие событий? Какие события всплывают какие нет? В чем разница между 
            target и currentTarget? Какие фазы события есть? Как можно их использовать?`,
            `Механизм, при котором после срабатывания события на элементе срабатывают события родительских элементов
            по цепочке - снизу вверх. Всплывают все, кроме focus. Target показывает конкретный объект события (возможно
            вложенный), currentTarget - объект события, к которому привязан обработчик. Погружение, активная фаза, всплытие.
            Можно установить значение определенного флага в addEventListener в значение true - тогда событие будет 
            срабатывать при погружении.`
        )

    ]
}